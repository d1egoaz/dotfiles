# https://olafurpg.github.io/scalafmt/#Configuration
style = IntelliJ # options in https://github.com/olafurpg/scalafmt/blob/master/core/src/main/scala/org/scalafmt/config/Settings.scala#L20

# val intellij = default.copy(
#   continuationIndent = ContinuationIndent(2, 2),
#   align = default.align.copy(openParenCallSite = false),
#   optIn = default.optIn.copy(
#     configStyleArguments = false
#   ),
#   danglingParentheses = true
# )

maxColumn = 120
docstrings = ScalaDoc
# project.git = true

binPackImportSelectors = true
spaces.inImportCurlyBraces = false
spaces.neverAroundInfixTypes = ["@"]
rewrite.rules = [SortImports, PreferCurlyFors, RedundantParens]
# BEFORE
# import com.hootsuite.service.facebookstreaming.crypto.{
#   HmacSha1Crypto,
#   CryptoUtils,
#   DecryptedConfig
# }
#
# AFTER
# import com.hootsuite.service.facebookstreaming.crypto.{CryptoUtils, DecryptedConfig, HmacSha1Crypto}

align.openParenDefnSite = false
align.openParenCallSite = false
# true
# class FacebookHooks @Inject()(hmacSha1: HmacSha1Crypto,
#                               decryptedConfig: DecryptedConfig,
#                               eventbusProducer: FacebookStreamingRawEventProducer)
#     extends Controller {
#
# false
# class FacebookHooks @Inject()(
#   hmacSha1: HmacSha1Crypto,
#   decryptedConfig: DecryptedConfig,
#   eventbusProducer: FacebookStreamingRawEventProducer
# ) extends Controller {

# indentOperator = ?? # to make infix operation have the same level as root
# default
# override protected val statusEndpoints: Seq[StatusEndpoint] = {
#   createExternalServiceStatusEndpoints() ++
#     createInternalStatusEndpoints()
# }
# spray
# override protected val statusEndpoints: Seq[StatusEndpoint] = {
#   createExternalServiceStatusEndpoints() ++
#   createInternalStatusEndpoints()
# }

continuationIndent.defnSite = 2
continuationIndent.callSite = 2
continuationIndent.extendSite = 2
# Value: 4
# class FacebookHooks @Inject()(
#     hmacSha1: HmacSha1Crypto,
#     decryptedConfig: DecryptedConfig,
#     eventbusProducer: FacebookStreamingRawEventProducer
# ) extends Controller {
# Value: 2
# class FacebookHooks @Inject()(
#   hmacSha1: HmacSha1Crypto,
#   decryptedConfig: DecryptedConfig,
#   eventbusProducer: FacebookStreamingRawEventProducer
# ) extends Controller {

binPack.parentConstructors = false
# true
# ) extends Controller with VoltronStatusActions {
# or
# } with DefaultEventBusConsumerConfigComponent with DefaultKafkaConsumerConnectorFactoryComponent
# with ActorSystemComponent with DefaultStatsdComponent with EventBusConsumer
# false
# ) extends Controller
#     with VoltronStatusActions {
# or

danglingParentheses = true
# true
# InternalServerError(
#   Json.toJson(ErrorResponse(errorCode = ErrorCodes.InternalServerError, errorMessage = errMsg))
# )
# false
# InternalServerError(
#   Json.toJson(ErrorResponse(errorCode = ErrorCodes.InternalServerError, errorMessage = errMsg)))

unindentTopLevelOperators = true
# true
# .exists(
#   uuid =>
#     uuid.mostSignificantBits == rawEventReceivedUuid.getMostSignificantBits &&
#     uuid.leastSignificantBits == rawEventReceivedUuid.getLeastSignificantBits
# )
# false
# .exists(
#   uuid =>
#     uuid.mostSignificantBits == rawEventReceivedUuid.getMostSignificantBits &&
#       uuid.leastSignificantBits == rawEventReceivedUuid.getLeastSignificantBits
# )
newlines.alwaysBeforeCurlyBraceLambdaParams = false
# true
# def postReceiveFacebookUpdates: Action[RawBuffer] = Action.async(parse.raw) {
#   request =>
#     statsd.timedFuture(MetricKeys.Controller.FacebookUpdates.receiveUpdate) {
#       val requestInfo = s"request info: POST ${request.path} headers: ${request.headers}"
# false
# def postReceiveFacebookUpdates: Action[RawBuffer] = Action.async(parse.raw) { request =>
#   statsd.timedFuture(MetricKeys.Controller.FacebookUpdates.receiveUpdate) {
#     val requestInfo = s"request info: POST ${request.path} headers: ${request.headers}"
#     Logger.info(requestInfo)

optIn.configStyleArguments = false # has to be false to make danglingParentheses work
# true
#   Future.successful(
#     Seq(registrationRecord.copy(serviceName = "foo"), registrationRecord.copy(serviceName = "bar")))
# )
# false
#   Future
#     .successful(Seq(registrationRecord.copy(serviceName = "foo"), registrationRecord.copy(serviceName = "bar")))


# scala.js specifics ?
# binPack.callSite = false
# binPack.defnSite = false

# align.tokens = [
#   { code = "%", owner = "Infix" }
#   { code = "%%", owner = "Infix" },
#   # "%%",
#   # "%"
# ]

# bestEffortInDeeplyNestedCode = false
#indentOperator.exclude = "^(::|&&|\\|\\|)$"
includeCurlyBraceInSelectChains = false # https://github.com/olafurpg/scalafmt/blob/master/core/src/test/resources/optIn/SelectChain.stat

optIn.breakChainOnFirstMethodDot = false
optIn.annotationNewlines = false

#
#  If false,
#  function(new Actor {
#      def foo = 2
#  })
#  If true,
#  function(
#    new Actor {
#      def foo = 2
#    }
#  )
#


# true
# resourceGenerators in Compile += Def
#   .task {
#     val file = (resourceManaged in Compile).value / "version.txt"
# false
# resourceGenerators in Compile += Def.task {

# newlines.sometimesBeforeColonInMethodReturnType = false

# scalafmt -f /Users/diegoa/dev/scala/service-facebook-data-validation/service/src/main/scala/com/hootsuite/service/facebookdatavalidation/data/dao/events/FacebookEventLogDataProvider.scala --config=/Users/diegoa/.scalafmt.conf -i
# scalafmt -f service --config=/Users/diegoa/.scalafmt.conf -i

# NOTES

# SBT
# show scalafmtConfig
# scalafmtConfig := Some(file("~/.scalafmt"))

#  // format: off,  // format: on // @formatter:off

# align.arrowEnumeratorGenerator = true
align.mixedOwners = false

newlines.penalizeSingleSelectMultiArgList = false
binPack.literalArgumentLists = true

align.tokens = ["%", "%%"]
# align.tokens = ["%", "%%", "="]